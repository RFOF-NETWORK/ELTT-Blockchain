"""
ELTT-Launcher.py

Zweck:
    Root-Python-Launcher-Viewer für das ELTT-Projekt.
    Neutral‑Matrix (VIEWER): rein lesend, aggregierend, keine STATE‑Mutationen.
    Liefert Node- und Service-Health-Views, Start-/Uptime-Status und UI‑Payloads für ui.js;
    Referenzimplementierung für Parity‑Sichten und Validator‑Stubs.

Autor:
    AutoGenerated gemäß MASTER DIRECTIVE MODULE 6→1

Erstellungsdatum:
    2026-02-08

Pfad (Repo):
    Root/ELTT-Launcher.py

Abhängigkeiten (architektonisch):
    - ELTT-Blockchain.py (lesende Schnittstelle zur Engine/Chain-State) optional
    - ELTT-Viewer.py (optionale Hilfsfunktionen)
    - ELTT-Validator.py (optional: lesende Einsicht in Validierungsstatus / Fehler)
    - PYTHON-ELTT-MODULE-PARITY/*/c_parity/ELTT-launcher.c (C‑Parity Hinweis)
    - Externe Adapter/Clients müssen außerhalb dieses Moduls bereitgestellt werden

Matrix-Rolle:
    Neutral‑Matrix (VIEWER) — ausschließlich Lesen, Anzeigen, Aggregieren.

UI Bindings (erwartet):
    - Event: "node:health" -> payload: { service: str, status: "ok"|"degraded"|"down", last_checked: float, severity: str, details: Optional[Dict] }
    - Event: "node:status" -> payload: { node_id: str, uptime_seconds: int, version: str, peers: int, syncing: bool }
    - Event: "service:list" -> payload: [{ service: str, status, last_checked, severity, message }, ...]

Erwartete Adapter‑Protokolle (Signaturen):
    class NodeClientProtocol:
        def fetch_node_status(self, node_id: str) -> Dict[str, Any]: ...
        def fetch_all_nodes(self) -> Iterable[Dict[str, Any]]: ...
        def fetch_service_health(self, service_name: str) -> Dict[str, Any]: ...
        def fetch_all_services(self) -> Iterable[Dict[str, Any]]: ...

ValidationResult Schema (Verweis):
    { "ok": bool, "code": str, "severity": str, "message": str, "details": Optional[Dict] }
"""

from dataclasses import dataclass
from typing import Dict, List, Any, Optional, Protocol, Iterable
import time

# ---------------------------------------------------------------------------
# Adapter-Protokolle (rein lesend)
# ---------------------------------------------------------------------------

class NodeClientProtocol(Protocol):
    def fetch_node_status(self, node_id: str) -> Dict[str, Any]: ...
    def fetch_all_nodes(self) -> Iterable[Dict[str, Any]]: ...
    def fetch_service_health(self, service_name: str) -> Dict[str, Any]: ...
    def fetch_all_services(self) -> Iterable[Dict[str, Any]]: ...

# ---------------------------------------------------------------------------
# Datamodelle
# ---------------------------------------------------------------------------

@dataclass(frozen=True)
class ServiceHealthView:
    service: str
    status: str  # "ok", "degraded", "down"
    last_checked: float
    severity: str  # "info", "warning", "high"
    message: Optional[str]

@dataclass(frozen=True)
class NodeStatusView:
    node_id: str
    uptime_seconds: int
    version: str
    peers: int
    syncing: bool
    last_checked: float

@dataclass(frozen=True)
class LauncherOverviewView:
    nodes: List[NodeStatusView]
    services: List[ServiceHealthView]
    aggregated_severity: str  # "info", "warning", "high"

# ---------------------------------------------------------------------------
# Lesender Adapter / Reader
# ---------------------------------------------------------------------------

class LauncherReader:
    """
    Lesender Adapter für Node/Service-Status. Keine Mutationen.
    """

    def __init__(self, node_client: NodeClientProtocol) -> None:
        self._node_client = node_client

    def get_node_status(self, node_id: str) -> NodeStatusView:
        raw = dict(self._node_client.fetch_node_status(node_id))
        # Defensive defaults for missing fields (read-only)
        uptime = int(raw.get("uptime_seconds", 0))
        version = str(raw.get("version", "unknown"))
        peers = int(raw.get("peers", 0))
        syncing = bool(raw.get("syncing", False))
        last_checked = float(raw.get("last_checked", time.time()))
        return NodeStatusView(
            node_id=node_id,
            uptime_seconds=uptime,
            version=version,
            peers=peers,
            syncing=syncing,
            last_checked=last_checked,
        )

    def list_nodes(self) -> List[NodeStatusView]:
        raw_nodes = list(self._node_client.fetch_all_nodes())
        nodes: List[NodeStatusView] = []
        for n in raw_nodes:
            node_id = str(n.get("node_id", "unknown"))
            nodes.append(self.get_node_status(node_id))
        return nodes

    def get_service_health(self, service_name: str) -> ServiceHealthView:
        raw = dict(self._node_client.fetch_service_health(service_name))
        status = str(raw.get("status", "unknown"))
        last_checked = float(raw.get("last_checked", time.time()))
        severity = str(raw.get("severity", "info"))
        message = raw.get("message")
        return ServiceHealthView(
            service=service_name,
            status=status,
            last_checked=last_checked,
            severity=severity,
            message=message,
        )

    def list_services(self) -> List[ServiceHealthView]:
        raw_services = list(self._node_client.fetch_all_services())
        services: List[ServiceHealthView] = []
        for s in raw_services:
            service_name = str(s.get("service", "unknown"))
            services.append(self.get_service_health(service_name))
        return services

# ---------------------------------------------------------------------------
# Aggregation: Launcher Overview (für UI)
# ---------------------------------------------------------------------------

def build_launcher_overview(launcher_reader: LauncherReader) -> LauncherOverviewView:
    nodes = launcher_reader.list_nodes()
    services = launcher_reader.list_services()

    # Aggregiere Schweregrad: high > warning > info
    severity_rank = {"info": 0, "warning": 1, "high": 2}
    max_rank = 0
    for s in services:
        rank = severity_rank.get(s.severity, 0)
        if rank > max_rank:
            max_rank = rank
    aggregated = "info"
    for k, v in severity_rank.items():
        if v == max_rank:
            aggregated = k
            break

    return LauncherOverviewView(nodes=nodes, services=services, aggregated_severity=aggregated)

# ---------------------------------------------------------------------------
# Serialisierung für UI (Payload Schema)
# ---------------------------------------------------------------------------

def launcher_overview_to_payload(view: LauncherOverviewView) -> Dict[str, Any]:
    return {
        "nodes": [
            {
                "node_id": n.node_id,
                "uptime_seconds": n.uptime_seconds,
                "version": n.version,
                "peers": n.peers,
                "syncing": n.syncing,
                "last_checked": n.last_checked,
            }
            for n in view.nodes
        ],
        "services": [
            {
                "service": s.service,
                "status": s.status,
                "last_checked": s.last_checked,
                "severity": s.severity,
                "message": s.message,
            }
            for s in view.services
        ],
        "aggregated_severity": view.aggregated_severity,
    }

# ---------------------------------------------------------------------------
# Validator-Stub (leichtgewichtig, Python)
# ---------------------------------------------------------------------------

def validate_launcher_payload(payload: Dict[str, Any]) -> Dict[str, Any]:
    """
    Validator-Stub prüft grundlegende Schema-Konsistenz für Launcher-Payloads.
    Liefert ValidationResult-Dict:
    { "ok": bool, "code": str, "severity": str, "message": str, "details": Optional[Dict] }
    Hinweis: Performance-sensitive Prüfungen gehören in C-Validator (validator_launcher.c).
    """
    if not isinstance(payload, dict):
        return {"ok": False, "code": "V301_LAUNCHER_INVALID_TYPE", "severity": "high", "message": "Payload must be an object", "details": None}
    if "nodes" not in payload or not isinstance(payload.get("nodes"), list):
        return {"ok": False, "code": "V302_LAUNCHER_MISSING_NODES", "severity": "high", "message": "Missing or invalid nodes list", "details": None}
    if "services" not in payload or not isinstance(payload.get("services"), list):
        return {"ok": False, "code": "V303_LAUNCHER_MISSING_SERVICES", "severity": "high", "message": "Missing or invalid services list", "details": None}
    # Basic per-node checks (sample)
    for node in payload.get("nodes", []):
        if not isinstance(node.get("node_id"), str):
            return {"ok": False, "code": "V304_LAUNCHER_NODE_INVALID_ID", "severity": "warning", "message": "Node missing valid node_id", "details": node}
    return {"ok": True, "code": "V000_OK", "severity": "info", "message": "Launcher payload schema OK", "details": None}

# ---------------------------------------------------------------------------
# TODOs / Parity Hinweise
# ---------------------------------------------------------------------------
# - C-Parity: Erzeuge PYTHON-ELTT-MODULE-PARITY/*/c_parity/ELTT-launcher.c mit identischer API:
#     - int parity_fetch_node_status(const char *node_id, char *out_json, size_t out_len);
#     - int parity_fetch_all_nodes(char *out_json, size_t out_len);
#     - int parity_fetch_service_health(const char *service_name, char *out_json, size_t out_len);
#     - int parity_fetch_all_services(char *out_json, size_t out_len);
# - Validator Parity: parity/validator/validator_launcher.c und validator_launcher.py implementieren performance-sensitive checks:
#     - node uptime sanity checks
#     - version format validation
#     - service flapping detection heuristics
# - UI: ui.js erwartet Events "node:health", "node:status", "service:list" mit payloads wie oben.
# - Unit-Test-Skelette:
#     - test_launcher_reader_get_node_status
#     - test_build_launcher_overview_payload_schema
#     - test_validate_launcher_payload_basic_checks

# ---------------------------------------------------------------------------
# Hinweis:
# - Dieses Modul ist rein lesend (Neutral‑Matrix). Keine Funktionen hier dürfen STATE mutieren.
# - Alle Pfad‑Referenzen und Parity‑Hinweise sind im Kopfkommentar dokumentiert.
# ---------------------------------------------------------------------------
