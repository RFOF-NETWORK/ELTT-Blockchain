/*
 * ELTT-Launcher.c
 *
 * Zweck:
 *   Root-C-Parity-/Viewer-Modul für Node- und Service-Health im ELTT-Projekt.
 *   Rein lesend (Neutral-Matrix): serialisiert Node-/Service-Status als JSON
 *   für Python-Viewer (ELTT-Launcher.py), UI (ui.js) und Validator.
 *
 * Autor: AutoGenerated gemäß MASTER DIRECTIVE MODULE 6→1
 * Erstellungsdatum: 2026-02-08
 *
 * Pfad:
 *   Root/ELTT-Launcher.c
 *
 * Abhängigkeiten (logisch):
 *   - Node-/Service-Monitor (extern, z. B. ELTT-Launcher-Engine)
 *   - validator_launcher.c (performance-sensitive Checks, nicht hier)
 *
 * Matrix-Rolle:
 *   Neutral-Matrix (VIEWER / PARITY) — keine Mutationen.
 *
 * Exportierte API (C-Parity zu ELTT-Launcher.py):
 *   int parity_fetch_node_status(const char *node_id, char *out_json, size_t out_len);
 *   int parity_fetch_all_nodes(char *out_json, size_t out_len);
 *   int parity_fetch_service_health(const char *service_name, char *out_json, size_t out_len);
 *   int parity_fetch_all_services(char *out_json, size_t out_len);
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <time.h>

#ifndef ELTT_LAUNCHER_H
#define ELTT_LAUNCHER_H

#ifdef __cplusplus
extern "C" {
#endif

/* -------------------------------------------------------------------------
 * Minimal gemeinsame Typen
 * ------------------------------------------------------------------------- */

#define ELTT_MAX_NODE_ID_LEN   64
#define ELTT_MAX_SERVICE_NAME  64
#define ELTT_MAX_NODES         64
#define ELTT_MAX_SERVICES      64

typedef struct {
    char  node_id[ELTT_MAX_NODE_ID_LEN];
    int   uptime_seconds;
    char  version[32];
    int   peers;
    int   syncing;       /* 0/1 */
    double last_checked; /* epoch seconds */
} eltt_node_status;

typedef struct {
    char  service[ELTT_MAX_SERVICE_NAME];
    char  status[16];    /* "ok", "degraded", "down" */
    double last_checked;
    char  severity[16];  /* "info", "warning", "high" */
    char  message[128];
} eltt_service_health;

typedef struct {
    size_t node_count;
    eltt_node_status nodes[ELTT_MAX_NODES];
    size_t service_count;
    eltt_service_health services[ELTT_MAX_SERVICES];
} eltt_launcher_state;

/* Diese Funktion(en) werden typischerweise von einer Launcher-Engine bereitgestellt */
extern int eltt_launcher_fetch_state(eltt_launcher_state *out_state);

/* -------------------------------------------------------------------------
 * Helper
 * ------------------------------------------------------------------------- */

static void safe_copy(char *dst, const char *src, size_t n) {
    if (!dst || n == 0) return;
    if (!src) src = "";
    strncpy(dst, src, n - 1);
    dst[n - 1] = '\0';
}

/* -------------------------------------------------------------------------
 * JSON-Serialisierung
 * ------------------------------------------------------------------------- */

static int write_node_status_json(const eltt_node_status *n, char *out_json, size_t out_len) {
    if (!n || !out_json || out_len == 0) return -1;
    int w = snprintf(
        out_json,
        out_len,
        "{\"node_id\":\"%s\",\"uptime_seconds\":%d,\"version\":\"%s\","
        "\"peers\":%d,\"syncing\":%d,\"last_checked\":%.3f}",
        n->node_id,
        n->uptime_seconds,
        n->version,
        n->peers,
        n->syncing,
        n->last_checked
    );
    return (w >= 0 && (size_t)w < out_len) ? 0 : -2;
}

static int write_all_nodes_json(const eltt_launcher_state *state, char *out_json, size_t out_len) {
    if (!state || !out_json || out_len == 0) return -1;
    size_t used = 0;
    int w = snprintf(out_json + used, out_len - used, "[");
    if (w < 0 || (size_t)w >= out_len - used) return -2;
    used += (size_t)w;

    for (size_t i = 0; i < state->node_count; ++i) {
        char buf[256];
        if (write_node_status_json(&state->nodes[i], buf, sizeof(buf)) != 0) return -2;
        w = snprintf(out_json + used, out_len - used, "%s%s", (i == 0 ? "" : ","), buf);
        if (w < 0 || (size_t)w >= out_len - used) return -2;
        used += (size_t)w;
    }

    w = snprintf(out_json + used, out_len - used, "]");
    if (w < 0 || (size_t)w >= out_len - used) return -2;
    used += (size_t)w;
    return 0;
}

static int write_service_health_json(const eltt_service_health *s, char *out_json, size_t out_len) {
    if (!s || !out_json || out_len == 0) return -1;
    int w = snprintf(
        out_json,
        out_len,
        "{\"service\":\"%s\",\"status\":\"%s\",\"last_checked\":%.3f,"
        "\"severity\":\"%s\",\"message\":\"%s\"}",
        s->service,
        s->status,
        s->last_checked,
        s->severity,
        s->message
    );
    return (w >= 0 && (size_t)w < out_len) ? 0 : -2;
}

static int write_all_services_json(const eltt_launcher_state *state, char *out_json, size_t out_len) {
    if (!state || !out_json || out_len == 0) return -1;
    size_t used = 0;
    int w = snprintf(out_json + used, out_len - used, "[");
    if (w < 0 || (size_t)w >= out_len - used) return -2;
    used += (size_t)w;

    for (size_t i = 0; i < state->service_count; ++i) {
        char buf[256];
        if (write_service_health_json(&state->services[i], buf, sizeof(buf)) != 0) return -2;
        w = snprintf(out_json + used, out_len - used, "%s%s", (i == 0 ? "" : ","), buf);
        if (w < 0 || (size_t)w >= out_len - used) return -2;
        used += (size_t)w;
    }

    w = snprintf(out_json + used, out_len - used, "]");
    if (w < 0 || (size_t)w >= out_len - used) return -2;
    used += (size_t)w;
    return 0;
}

/* -------------------------------------------------------------------------
 * Öffentliche API
 * ------------------------------------------------------------------------- */

int parity_fetch_node_status(const char *node_id, char *out_json, size_t out_len) {
    if (!node_id || !out_json || out_len == 0) return -1;
    eltt_launcher_state state;
    memset(&state, 0, sizeof(state));
    if (eltt_launcher_fetch_state(&state) != 0) {
        safe_copy(out_json, "{}", out_len);
        return -2;
    }
    for (size_t i = 0; i < state.node_count; ++i) {
        if (strcmp(state.nodes[i].node_id, node_id) == 0) {
            return write_node_status_json(&state.nodes[i], out_json, out_len);
        }
    }
    safe_copy(out_json, "{}", out_len);
    return 0;
}

int parity_fetch_all_nodes(char *out_json, size_t out_len) {
    if (!out_json || out_len == 0) return -1;
    eltt_launcher_state state;
    memset(&state, 0, sizeof(state));
    if (eltt_launcher_fetch_state(&state) != 0) {
        safe_copy(out_json, "[]", out_len);
        return -2;
    }
    return write_all_nodes_json(&state, out_json, out_len);
}

int parity_fetch_service_health(const char *service_name, char *out_json, size_t out_len) {
    if (!service_name || !out_json || out_len == 0) return -1;
    eltt_launcher_state state;
    memset(&state, 0, sizeof(state));
    if (eltt_launcher_fetch_state(&state) != 0) {
        safe_copy(out_json, "{}", out_len);
        return -2;
    }
    for (size_t i = 0; i < state.service_count; ++i) {
        if (strcmp(state.services[i].service, service_name) == 0) {
            return write_service_health_json(&state.services[i], out_json, out_len);
        }
    }
    safe_copy(out_json, "{}", out_len);
    return 0;
}

int parity_fetch_all_services(char *out_json, size_t out_len) {
    if (!out_json || out_len == 0) return -1;
    eltt_launcher_state state;
    memset(&state, 0, sizeof(state));
    if (eltt_launcher_fetch_state(&state) != 0) {
        safe_copy(out_json, "[]", out_len);
        return -2;
    }
    return write_all_services_json(&state, out_json, out_len);
}

#ifdef __cplusplus
}
#endif

#endif /* ELTT_LAUNCHER_H */

/* Ende: Root/ELTT-Launcher.c */
