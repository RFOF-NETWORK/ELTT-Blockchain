"""
ELTT-Staking.py

Zweck:
    Root-Python-Staking-Viewer und Staking-Validator-Stubs für das ELTT-Projekt.
    Staking Firewall (Neutral/Negativ-Matrix): lesende Sichten, Validierungs‑Stubs,
    Lock/Unlock-Regeln, Reward‑Berechnungs‑Skeletons und UI‑Payloads für ui.js.
    Keine State‑Mutationen; heavy checks und performance-sensitive Prüfungen gehören
    in C‑Parity / validator_staking.c.

Autor:
    AutoGenerated gemäß MASTER DIRECTIVE MODULE 6→1

Erstellungsdatum:
    2026-02-08

Pfad (Repo):
    Root/ELTT-Staking.py

Abhängigkeiten (architektonisch):
    - ELTT-Blockchain.py (lesende Schnittstelle zur Engine/Chain-State)
    - ELTT-Validator.py (optional: zentrale Fehlercodes / shared ValidationResult)
    - PYTHON-ELTT-MODULE-PARITY/*/c_parity/ELTT-staking.c (C‑Parity Hinweis)
    - parity/validator/validator_staking.c and validator_staking.py (Validator Parity)
    - Externe Adapter/Clients müssen außerhalb dieses Moduls bereitgestellt werden

Matrix-Rolle:
    Negativ‑Matrix (STAKING-FIREWALL) — Validierung, Regeln, keine Positiv‑Mutationen.

UI Bindings (erwartet):
    - Event: "staking:positions" -> payload: [{ position_id, staker_address, staked_amount, token_symbol, lock_until, pending_rewards, status }, ...]
    - Event: "staking:invalid" -> payload: { position_id, code, message }

ValidationResult Schema (Verweis):
    { "ok": bool, "code": str, "severity": str, "message": str, "details": Optional[Dict] }
"""

from dataclasses import dataclass
from typing import Dict, List, Any, Optional, Protocol, Iterable
import time
import math

# ---------------------------------------------------------------------------
# Adapter-Protokolle (rein lesend)
# ---------------------------------------------------------------------------

class StakingClientProtocol(Protocol):
    def fetch_positions_by_address(self, address: str) -> Iterable[Dict[str, Any]]: ...
    def fetch_position(self, position_id: str) -> Optional[Dict[str, Any]]: ...
    def fetch_global_staking_parameters(self) -> Dict[str, Any]: ...

class EngineClientProtocol(Protocol):
    def fetch_token_price(self, token_symbol: str) -> Optional[float]: ...

# ---------------------------------------------------------------------------
# Datamodelle
# ---------------------------------------------------------------------------

@dataclass(frozen=True)
class StakingPositionView:
    position_id: str
    staker_address: str
    staked_amount: float
    token_symbol: str
    lock_until: float  # epoch seconds
    pending_rewards: float
    status: str  # "active", "unlocking", "closed", "invalid"
    start_timestamp: Optional[float] = None

@dataclass(frozen=True)
class StakingOverviewView:
    address: str
    positions: List[StakingPositionView]
    total_staked: float
    total_pending_rewards: float
    aggregated_status: str  # "ok", "warning", "critical"

# ---------------------------------------------------------------------------
# StakingReader (lesender Adapter)
# ---------------------------------------------------------------------------

class StakingReader:
    """
    Lesender Adapter für Staking-Informationen. Keine Mutationen.
    """

    def __init__(self, staking_client: StakingClientProtocol, engine_client: Optional[EngineClientProtocol] = None) -> None:
        self._staking = staking_client
        self._engine = engine_client

    def list_positions_for_address(self, address: str) -> List[StakingPositionView]:
        raw_positions = list(self._staking.fetch_positions_by_address(address))
        positions: List[StakingPositionView] = []
        for p in raw_positions:
            positions.append(
                StakingPositionView(
                    position_id=str(p.get("position_id")),
                    staker_address=str(p.get("staker_address", address)),
                    staked_amount=float(p.get("staked_amount", 0.0)),
                    token_symbol=str(p.get("token_symbol", "ELTT")),
                    lock_until=float(p.get("lock_until", 0.0)),
                    pending_rewards=float(p.get("pending_rewards", 0.0)),
                    status=str(p.get("status", "active")),
                    start_timestamp=(float(p.get("start_timestamp")) if p.get("start_timestamp") is not None else None),
                )
            )
        return positions

    def get_position(self, position_id: str) -> Optional[StakingPositionView]:
        raw = self._staking.fetch_position(position_id)
        if raw is None:
            return None
        return StakingPositionView(
            position_id=str(raw.get("position_id")),
            staker_address=str(raw.get("staker_address", "")),
            staked_amount=float(raw.get("staked_amount", 0.0)),
            token_symbol=str(raw.get("token_symbol", "ELTT")),
            lock_until=float(raw.get("lock_until", 0.0)),
            pending_rewards=float(raw.get("pending_rewards", 0.0)),
            status=str(raw.get("status", "active")),
            start_timestamp=(float(raw.get("start_timestamp")) if raw.get("start_timestamp") is not None else None),
        )

    def compute_position_reward_estimate(self, position: StakingPositionView) -> Optional[float]:
        """
        Schätzt Rewards basierend auf globalen Parametern und Token-Preis (falls verfügbar).
        Dies ist ein neutraler, lesender Schätzer; exakte Reward-Logik gehört in Validator/Engine.
        """
        try:
            params = self._staking.fetch_global_staking_parameters()
        except Exception:
            params = {}

        apr = float(params.get("apr", 0.0))  # annual percentage rate as decimal (e.g., 0.05)
        if apr <= 0.0:
            return None

        # einfache lineare Schätzung: pending = staked_amount * apr * (duration_days / 365)
        now = time.time()
        start = position.start_timestamp or now
        duration_seconds = max(0.0, now - start)
        duration_days = duration_seconds / 86400.0
        estimated = position.staked_amount * apr * (duration_days / 365.0)
        return float(estimated)

    def compute_position_value_usd(self, position: StakingPositionView) -> Optional[float]:
        if self._engine is None:
            return None
        price = self._engine.fetch_token_price(position.token_symbol)
        if price is None:
            return None
        return position.staked_amount * price

# ---------------------------------------------------------------------------
# Aggregation: Staking Overview (für UI)
# ---------------------------------------------------------------------------

def build_staking_overview(staking_reader: StakingReader, address: str) -> StakingOverviewView:
    positions = staking_reader.list_positions_for_address(address)
    total_staked = sum(p.staked_amount for p in positions)
    total_pending = sum(p.pending_rewards for p in positions)
    # Aggregated status: critical if any invalid or unlocking with expired lock
    agg = "ok"
    now = time.time()
    for p in positions:
        if p.status == "invalid":
            agg = "critical"
            break
        if p.status == "unlocking" and p.lock_until > 0 and p.lock_until < now:
            agg = "warning"
    return StakingOverviewView(
        address=address,
        positions=positions,
        total_staked=total_staked,
        total_pending_rewards=total_pending,
        aggregated_status=agg,
    )

def staking_overview_to_payload(view: StakingOverviewView) -> Dict[str, Any]:
    return {
        "address": view.address,
        "positions": [
            {
                "position_id": p.position_id,
                "staker_address": p.staker_address,
                "staked_amount": p.staked_amount,
                "token_symbol": p.token_symbol,
                "lock_until": p.lock_until,
                "pending_rewards": p.pending_rewards,
                "status": p.status,
                "start_timestamp": p.start_timestamp,
            }
            for p in view.positions
        ],
        "total_staked": view.total_staked,
        "total_pending_rewards": view.total_pending_rewards,
        "aggregated_status": view.aggregated_status,
    }

# ---------------------------------------------------------------------------
# Staking Rule Engine (Lightweight, read-only heuristics)
# ---------------------------------------------------------------------------

def evaluate_lock_rule(position: StakingPositionView, current_time: Optional[float] = None) -> Dict[str, Any]:
    """
    Evaluates basic lock/unlock rules and returns a small diagnostic dict:
    { "ok": bool, "code": str, "message": str, "can_withdraw": bool }
    Heavy rule enforcement belongs to stakingvalidatorbridge / C validator.
    """
    now = current_time if current_time is not None else time.time()
    if position.lock_until <= 0:
        return {"ok": True, "code": "S000_NO_LOCK", "message": "No lock set", "can_withdraw": True}
    if now >= position.lock_until:
        return {"ok": True, "code": "S001_LOCK_EXPIRED", "message": "Lock expired", "can_withdraw": True}
    # still locked
    return {"ok": False, "code": "S002_LOCK_ACTIVE", "message": "Position still locked", "can_withdraw": False}

# ---------------------------------------------------------------------------
# Validator-Stub (leichtgewichtig, Python)
# ---------------------------------------------------------------------------

def validate_staking_position_payload(payload: Dict[str, Any]) -> Dict[str, Any]:
    """
    Validator-Stub prüft grundlegende Schema-Konsistenz für Staking-Position-Payloads.
    Liefert ValidationResult-Dict:
    { "ok": bool, "code": str, "severity": str, "message": str, "details": Optional[Dict] }
    Hinweis: Performance-sensitive Prüfungen gehören in C-Validator (validator_staking.c).
    """
    if not isinstance(payload, dict):
        return {"ok": False, "code": "V401_STAKING_INVALID_TYPE", "severity": "high", "message": "Payload must be an object", "details": None}
    required = ["position_id", "staker_address", "staked_amount", "token_symbol", "lock_until", "pending_rewards", "status"]
    missing = [k for k in required if k not in payload]
    if missing:
        return {"ok": False, "code": "V402_STAKING_MISSING_FIELDS", "severity": "high", "message": f"Missing fields: {', '.join(missing)}", "details": {"missing": missing}}
    try:
        if float(payload.get("staked_amount", 0)) < 0:
            return {"ok": False, "code": "V403_STAKING_NEGATIVE_AMOUNT", "severity": "high", "message": "Staked amount must be non-negative", "details": None}
        if float(payload.get("pending_rewards", 0)) < 0:
            return {"ok": False, "code": "V404_STAKING_NEGATIVE_REWARDS", "severity": "high", "message": "Pending rewards must be non-negative", "details": None}
    except Exception:
        return {"ok": False, "code": "V405_STAKING_INVALID_NUMERIC", "severity": "high", "message": "Numeric fields invalid", "details": None}
    # Basic lock_until sanity: not far in the past beyond reasonable threshold
    lock_until = float(payload.get("lock_until", 0))
    now = time.time()
    if lock_until != 0 and lock_until < now - (365 * 24 * 3600):  # older than 1 year in past
        return {"ok": False, "code": "V406_STAKING_LOCK_PAST", "severity": "warning", "message": "Lock timestamp suspiciously far in the past", "details": {"lock_until": lock_until}}
    return {"ok": True, "code": "V000_OK", "severity": "info", "message": "Staking payload schema OK", "details": None}

# ---------------------------------------------------------------------------
# TODOs / Parity Hinweise
# ---------------------------------------------------------------------------
# - C-Parity: Erzeuge PYTHON-ELTT-MODULE-PARITY/*/c_parity/ELTT-staking.c mit identischer API:
#     - int parity_fetch_positions_by_address(const char *address, char *out_json, size_t out_len);
#     - int parity_fetch_position(const char *position_id, char *out_json, size_t out_len);
#     - int parity_fetch_global_staking_parameters(char *out_json, size_t out_len);
#     - int parity_compute_position_reward_estimate(const char *position_json, char *out_json, size_t out_len);
# - Validator Parity: parity/validator/validator_staking.c and validator_staking.py implement performance-sensitive checks:
#     - lock/unlock rule enforcement
#     - reward calculation verification
#     - double-stake / stake-splitting heuristics
# - Staking Firewall Bridge: implement stakingvalidatorbridge.py / stakingvalidatorbridge.c to mediate Validator <-> StakingReader calls.
# - UI: ui.js expects Event "staking:positions" with payload = staking_overview_to_payload(view)
# - Unit-Test-Skelette:
#     - test_staking_reader_list_positions_for_address
#     - test_compute_position_reward_estimate
#     - test_validate_staking_position_payload_edge_cases

# ---------------------------------------------------------------------------
# Hinweis:
# - Dieses Modul ist Teil der Staking Firewall (Negativ-Matrix) und liefert
#   sowohl Viewer-Sichten als auch Validator-Stubs. Es darf keine State-Mutationen durchführen.
# - Alle Pfad‑Referenzen und Parity‑Hinweise sind im Kopfkommentar dokumentiert.
# ---------------------------------------------------------------------------
